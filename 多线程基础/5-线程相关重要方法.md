---
abbrlink: '0'
---
为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而Sleep定义在Thread类里？



用3种方式实现生产者模式



join 和sleep和wait期间线程的状态分别是什么？为什么？

## Object类中wait,notify,notifyAll

Object类中wait()，notify()，notifyAll()作用，使用对象：锁对象

### 阻塞阶段

线程调用wait方法之前首先要获得monitor锁（对于synchronized必须是进入该代码块后），**调用其锁对象的wait()方法后当前线程会将该monitor锁释放，随后该线程会进入阻塞状态**

直到以下四种情况才会被唤醒：

* 另一个线程调用这个**锁对象**的notify()方法且刚好被唤醒的是本线程 ;
* 另一个线程调用这个**锁对象**的notifyAll()方法 ;
* 过了wait(long timeout)规定的超时时间，如果传入0就是永久等待;
* 线程自身调用了interrupt

### 唤醒阶段

notify()：

当调用了锁对象的notify()可以让需要该锁的随机一个**等待的**线程唤醒，如果多个线程都处于等待状态只会选择一个唤醒，选择权是jvm**随机的**

notifyAll()：

可以一次唤醒该锁的所有线程，如果多个线程在等待，可以全部被唤醒

被唤醒后的线程可以重新进入cpu的调度，当分配了执行权就可以执行

> wait()，notify()，notifyAll() 三个方法都需要在synchronized代码块内部执行（因为在内部说明已经获得了这把锁，拥有了执行权），否则会抛出异常

举例：线程1、2、3都在等待对象A的Monitor锁，如果线程4目前拥有这个锁（获得执行权），此时线程4调用notify()后就会随机的1\2\3线程唤醒其中一个。若使用notifyAll()会将三个线程全部唤醒，唤醒后的线程要想获得这把锁要等待cpu的调度。

遇到中断

如果当前线程被中断了，会抛出InterruptException，并且释放掉目前已经获取的monitor锁

下面我们来看一段代码：

### wait和notify代码

普通用法：

```java
/**
 * 描述：     展示wait和notify的基本用法 1. 研究代码执行顺序 2. 证明wait释放锁
 */
public class Wait {

    public static Object object = new Object();

    static class Thread1 extends Thread {

        @Override
        public void run() {
            synchronized (object) { //t1进入synchronized，说明持有了monitor锁
                System.out.println(Thread.currentThread().getName() + "开始执行了");
                try {
                    object.wait(); //调用wait() 后t1释放了这个锁，随后处于等待被唤醒的阶段
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程" + Thread.currentThread().getName() + "获取到了锁。");
            }
        }
    }

    static class Thread2 extends Thread {

        @Override
        public void run() {
            synchronized (object) { //thread1调用wait后释放了这个monitor锁，随后thread2获得该锁进入方法
                object.notify();//唤醒thread1线程
                System.out.println("线程" + Thread.currentThread().getName() + "调用了notify()");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread1 thread1 = new Thread1();
        Thread2 thread2 = new Thread2();
        thread1.start();
        Thread.sleep(200); //为了让thread1先执行保证先wait 后notify，t1 start后等一会
        thread2.start();
    }
}

```

执行结果：

![image-20211216105837854](https://image.imxyu.cn/file/image-20211216105837854.png)

因此我们可以看到wait()后t1会释放锁，随后t2拿到锁后进入synchronized 执行方法，当t2执行object.notify()后不会立马执行t1, 会将t2剩下的代码执行完之后再执行t1 

> 对于synchronized 不熟悉的请先看[第0讲-synchronized详解](https://imxyu.cn/post/311ad3.html )

接下来我们看看notify() 和notifyAll()的代码展示：

### notify() 和notifyAll()代码

首先我们来看看notifyAll（）

```java
/**
 * 描述：     3个线程，线程1和线程2首先被阻塞，线程3唤醒它们。notify, notifyAll。 start先执行不代表线程先启动。
 */
public class WaitNotifyAll implements Runnable {

    private static final Object resourceA = new Object();


    public static void main(String[] args) throws InterruptedException {
        Runnable r = new WaitNotifyAll();
        Thread threadA = new Thread(r);
        Thread threadB = new Thread(r);
        Thread threadC = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    resourceA.notifyAll(); //唤醒所有使用A对象锁的线程
//                    resourceA.notify();
                    System.out.println("ThreadC notified.");
                }
            }
        });
        threadA.start();
        threadB.start();
        Thread.sleep(200); //同样这里要等A和B运行了再运行C的notifyAll
        threadC.start();
    }
    @Override
    public void run() {
        synchronized (resourceA) {
            System.out.println(Thread.currentThread().getName()+" got resourceA lock.");
            try {
                System.out.println(Thread.currentThread().getName()+" waits to start.");
                resourceA.wait();
                System.out.println(Thread.currentThread().getName()+"'s waiting to end.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

执行结果：A先获得锁执行后wait（）释放锁，A释放后B得到该锁进入synchronized代码块，此时A和B都处于wait（）等待的状态，此时执行C的  notifyAll()。唤醒了两个线程A和B

![image-20211216112016570](https://image.imxyu.cn/file/image-20211216112016570.png)

如果将C的notifyAll() 换成了notify() 会有什么情况？

![image-20211216112654223](https://image.imxyu.cn/file/image-20211216112654223.png)

此时随机唤醒了一个线程，这里A被唤醒。此时B还在wait（）中

### wait只会释放当前对象的锁

wait后只会释放当前调用对象的锁，不会影响其他对象锁

下面我们用一段代码来验证

```java
/**
 * 描述：     证明wait只释放当前的那把锁
 */
public class WaitNotifyReleaseOwnMonitor {

    private static volatile Object resourceA = new Object();
    private static volatile Object resourceB = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resourceA) {
                    System.out.println("ThreadA got resourceA lock.");
                    synchronized (resourceB) {
                        System.out.println("ThreadA got resourceB lock.");
                        try {
                            System.out.println("ThreadA releases resourceA lock.");
                            resourceA.wait();

                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (resourceA) {
                    System.out.println("ThreadB got resourceA lock.");
                    System.out.println("ThreadB tries to resourceB lock.");

                    synchronized (resourceB) {
                        System.out.println("ThreadB got resourceB lock.");
                    }
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

执行结果

![image-20211216115237741](https://image.imxyu.cn/file/image-20211216115237741.png)

我们可以看到，resourceA.wait（）只会释放当前对象resourceA的锁，reosourceB没有释放，因此ThreadB一直在等待获取reosourceB的锁。因此我们想获取哪个对象的锁，就要执行相应对象的wait方法

### wait原理

![wait原理](https://image.imxyu.cn/file/wait%E5%8E%9F%E7%90%86.png)

绿色：代表正在等待获取锁的线程

紫色：表示已经获取锁的线程

蓝色：表示通过wait（）释放锁后的线程

粉色：wait()的通过notify()后正在等待获取锁的线程

### wait,notify,notifyAll性质

用必须先拥有Monitor锁，否则会抛出异常

notify只能唤醒一个使用该锁的对象的线程，由jvm虚拟机决定任意的一个

属于Object类，任意方法都可以调用

类似功能的Condition, 对其包装可以实现wait和notify

同时持有多个锁，wait只会释放当前调用对象的锁

### 六种状态的补充

![image-20211216143844498](https://image.imxyu.cn/file/image-20211216143844498.png)

学了这节的内容，我们可以在这里加两种转化的情况

