```java
package com.fisec.vpn.util;


import java.util.List;
import java.util.PriorityQueue;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

//优先队列
//创建链表最常用手段是建立一个虚拟节点
 class Solution {
    public ListNode mergeKLists(ListNode[] lists){

        if (lists.length==0){
            return null;
        }
        if (lists.length==1){
            return lists[0];
        }
        PriorityQueue<ListNode> priorityQueue=new PriorityQueue<>(lists.length,(a, b)->a.val-b.val);
        for (ListNode list : lists) {
            if (list!=null){
                priorityQueue.add(list);
            }
        }
        ListNode dummyHead=new ListNode(-1);
        ListNode temp=dummyHead;
        while (!priorityQueue.isEmpty()){
            ListNode poll = priorityQueue.poll();
            temp.next=poll;
            temp=temp.next;
            if (poll.next!=null){
                priorityQueue.add(poll.next);
            }
        }
        return dummyHead.next;

    }
}

class Solution2 {


    //分治,俩俩合并
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0){
            return null;
        }
      return mergeKLists(0, lists.length-1, lists);
    }

    private ListNode mergeKLists(int l, int r, ListNode[] lists) {
        if (l == r) {
            return lists[l];
        }
           
        int mid = (l+r) >> 1;
        ListNode l1 = mergeKLists(l, mid, lists);
        ListNode l2 = mergeKLists(mid + 1, r, lists);
        return mergeTwoLists(l1, l2);
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);

        ListNode prev = prehead;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
}


```
