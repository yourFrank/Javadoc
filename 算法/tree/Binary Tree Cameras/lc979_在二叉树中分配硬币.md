```java
package com.fisec.vpn.util;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    int res=0;
    public int distributeCoins(TreeNode root) {
        dfs(root);
        return res;
    }
    //返回root节点当前的硬币数量
    //每次迭代将子树所有的硬币集中到root节点上
    public int dfs(TreeNode root){
        if(null==root){
            return 0;
        }
        int leftCount=dfs(root.left);
        int rightCount=dfs(root.right);
        res+=Math.abs(leftCount)+Math.abs(rightCount);
        return leftCount+rightCount+root.val-1;

    }
}
//个人总结：node.val + L + R - 1 表示当前节点需要 拿给子节点的金币个数 或者 从子节点拿给自己的金币的个数，即当前节点的金币的移动次数。因为是后序遍历，所以能保证子节点已经都得到了需要的金币，同时 ans += Math.abs(L) + Math.abs(R);记录了子节点的移动次数，故累加后即是最终结果。
//核心思路，从底部往上迭代，我们要做的就是将每个子树分配一个硬币，剩下的全部集中到root节点 会存在一种情况，
//        就是需要root分配硬币给子树，但是其实这个可以视为子树分配-n个银币给了root节点， 所以dfs一轮返回的 值代表着 当前root节点的整颗树每个节点都分配一个硬币以后剩余的硬币数量。而dfs(left)/dfs(right)的绝对值就是需要分配的硬币数量

```
