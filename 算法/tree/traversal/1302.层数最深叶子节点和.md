```java
package com.fisec.vpn;

import java.util.Deque;
import java.util.LinkedList;

// Definition for a binary tree node.
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

//dfs 最开始想的是先求出最大层数，然后将当前层和最大层数做对比。将最大层的节点val相加
//后来看题解发现这两个步骤可以一起执行，当发现大层数时maxDepth更新最大层，sum更新为当前层的节点的val; 否则相等的话相加即可，小于的不处理
class Solution {
    int maxDepth = -1;
    int sum = 0;
    public int deepestLeavesSum(TreeNode root) {
        dfs(root, 0);
        return sum;
    }
    private void dfs(TreeNode root, int depth) {
        if (root==null){
            return ;
        }
        if (depth==maxDepth){
            sum+=root.val;
        }else if (maxDepth < depth){
            maxDepth=depth;
            sum=root.val;
        }
        dfs(root.left,depth+1);
        dfs(root.right,depth+1);
    }
}


//bfs
class Solution2 {

    private int sum;

    public int deepestLeavesSum(TreeNode root) {
        Deque<TreeNode> deque=new LinkedList<>();
        if (root!=null){
            deque.add(root);
        }
        while (!deque.isEmpty()){
            int size=deque.size();
            sum=0;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left!=null){
                    deque.add(poll.left);
                }
                if (poll.right!=null){
                    deque.add(poll.right);
                }
                sum+=poll.val;
            }
        }
        return sum;
    }

}
```
