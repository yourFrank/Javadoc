```java
package com.fisec.vpn.util;

import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}


//最开始想法，if判断比较多。很麻烦
class SolutionPre {
    //max代表节点个数
    private int max=1;
    public int longestUnivaluePath(TreeNode root) {
        if (root==null){
            return 0;
        }
        dfs(root);
        return max-1;
    }

    private int dfs(TreeNode root) {
        if (root==null){
            return 0;
        }
        int leftCount = dfs(root.left);
        int rightCount = dfs(root.right);

        if (root.left!=null&&root.right!=null){
            if (root.left.val==root.val&&root.val==root.right.val){
                max=Math.max(leftCount+rightCount+1,max );
                return 1+Math.max(leftCount,rightCount);
            }
             if (root.val==root.left.val){
                max=Math.max( 1+leftCount, max);
                return 1+leftCount;
            }
            if (root.val==root.right.val){
                max=Math.max( 1+rightCount, max);
                return 1+rightCount;
            }
        }
        if (root.left!=null&&root.val==root.left.val){
            max=Math.max( 1+leftCount, max);
            return 1+leftCount;
        }
        if (root.right!=null&&root.val==root.right.val){
            max=Math.max( 1+rightCount, max);
            return 1+rightCount;
        }
        return 1;
    }

}

//官方解法
class Solution {
    int ans;
    public int longestUnivaluePath(TreeNode root) {
        ans = 0;
        arrowLength(root);
        return ans;
    }
    public int arrowLength(TreeNode node) {
        if (node == null) return 0;
        int left = arrowLength(node.left);
        int right = arrowLength(node.right);
         //像这种情况可以使用两个变量定义初始值为0。如果两个都走了就都有值，走一个就一个有值，都没走就为0
        int arrowLeft = 0, arrowRight = 0;
        if (node.left != null && node.left.val == node.val) {
            arrowLeft += left + 1;
        }
        if (node.right != null && node.right.val == node.val) {
            arrowRight += right + 1;
        }
        //如果上面两个条件都成立了，说明left=right=node， 此时arrowLeft+arrowRight 就有值了，
        ans = Math.max(ans, arrowLeft + arrowRight);
        return Math.max(arrowLeft, arrowRight);
    }
}

//根据官方写法改的,用路径等于节点个数-1
class Solution2 {
    //此时表示的节点的个数
    int ans;
    public int longestUnivaluePath(TreeNode root) {
        ans = 1;
        arrowLength(root);
        //路径为节点个数-1
        return ans-1;
    }
    public int arrowLength(TreeNode node) {
        if (node == null) return 0;
        int left = arrowLength(node.left);
        int right = arrowLength(node.right);
        //像这种情况可以使用两个变量定义初始值为0。如果两个都走了就都有值，走一个就一个有值，都没走就为0
        int arrowLeft = 0, arrowRight = 0;
        if (node.left != null && node.left.val == node.val) {
            arrowLeft += left ;
        }
        if (node.right != null && node.right.val == node.val) {
            arrowRight += right ;
        }
        //如果上面两个条件都成立了，说明left=right=node， 此时arrowLeft+arrowRight 就有值了，
        ans = Math.max(ans, 1+arrowLeft + arrowRight);
        return 1+Math.max(arrowLeft, arrowRight);
    }
}


```
