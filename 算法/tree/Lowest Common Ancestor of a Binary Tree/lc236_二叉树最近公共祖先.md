```java
package com.fisec.vpn.util;


class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

/*
这道题首先要分析规律：p和q可能有两种分布情况

        情况一：p和q分布在了当前根的左子树和右子树上面，此时当前根就是二者的最近公共祖先，递归中可直接返回当前根结点。

        情况二：p和q分布在了当前根的某一边的子树上，当前根结点为p和q其中之一也归结为此情况。

        递归时，我们想象是递归查找p或者q，如果当前root是p或者q直接返回，如果当前root不是p或者q，那么就像左右递归，判空得到左右子树存在p和q的情况，都存在那么直接返回root。否则直接返回左右存在的那个返回值，因为p和q都存在同一棵子树上，那么第一个找到的点就是最后的答案。

*/
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root==null){
            return null;
        }
        if (root==p||root==q){
            return root;
        }
        TreeNode left=lowestCommonAncestor(root.left,p,q);
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if (left!=null&&right!=null){
            return root;
        }
        return left!=null?left:right;

    }
}

```
