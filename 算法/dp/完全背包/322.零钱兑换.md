```java
package com.fisec.vpn.util;


import java.util.Arrays;

//零钱兑换，凑出总金额所需的最小个数，如果没有一种能组成返回-1,硬币数量无限
//dp[i][j] 从前i个中选择，凑出金额为j 的最小个数
//二维思考
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n=coins.length;
        int dp[][]=new int[n+1][amount+1];

        for (int i = 0; i < n + 1; i++) {
            for (int j = 0; j <= amount; j++) {
               dp[i][j]=amount+1;

            }
        }
        dp[0][0]=0;
        for (int i = 1; i < n + 1; i++) {
            for (int j = 0; j <= amount; j++) {
                if (coins[i-1]<=j){//如果可以选择
                    dp[i][j]=Math.min(dp[i-1][j],dp[i][j-coins[i-1]]+1);
                }else{
                    dp[i][j] = dp[i - 1][j];
                }

            }
        }
        return dp[n][amount]==amount+1?-1:dp[n][amount];
    }
}


//零钱兑换，返回组成amount的最小个数，不能组成返回-1
//因为dp[i]可以根据之前的dp[i-coins]获取到故用Dp，dp[i] 表示能组成i面值的硬币的最小个数
//一维思考
class Solution2 {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp,amount+1);//base case 为amount+1，因为最多可以放amount，这里不能是MAX_VALUE.下面+1会越界
        dp[0] = 0;//组成0的个数为0
        //遍历所有状态
        for (int i = 1; i <= amount; i++) {
            //做选择
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i-coins[j]] + 1);
                }
            }
        }
        return dp[amount]==amount+1?-1:dp[amount];

    }
}




```
