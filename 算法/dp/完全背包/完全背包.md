---
title: 完全背包
tags:
  - 动态规划
categories:
  - 算法
cover: >-
  https://image.imxyu.cn/file/Logo_%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-100-480x480px.png
description: 动态规划-完全背包
abbrlink: e5fcf0c8
date: 2021-12-08 16:28:43
---

## 完全背包介绍

有 N种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

## 思考框架

![1.jpg.png](https://image.imxyu.cn/file/52888_8fb0f19a36-1.jpg.png)

当i选择k个的时候：f [i-1,j-k * v[i]]  + k * w[i]（其中这里已经包含了当i=0的时候，就是不选择i的时候）

留出k个元素的空间，加上K个元素的价值

取k个元素，看哪个最大。因此就是这k次循环中取max

## 朴素写法代码

acwing:https://www.acwing.com/problem/content/description/3/

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws Exception {
        //***********读入数据代码开始**************
        Scanner reader = new Scanner(System.in);
        // 物品的数量为N
        int N = reader.nextInt();
        // 背包的容量为V
        int V = reader.nextInt();
        //v[i]表示第i个元素的容量,w[i]表示第i个元素的价值
        int[] v = new int[N + 1];
        int[] w = new int[N + 1];

        //这里索引从1开始，索引下标代表第i个物品
        for (int i = 1; i <= N; i++) {
            v[i] = reader.nextInt();
            w[i] = reader.nextInt();
        }
        reader.close();
        //***********读入数据代码结束**************

        int[][] dp = new int[N + 1][V + 1];
    
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= V; j++) {
                for (int k = 0; k * v[i] <= j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);
                }

            }
            
        }
        System.out.println(dp[N][V]); 

    }
}
```

## k循环优化

我们将k=0,k=1,k.....式子展开

        k个循环寻找最大值，我们可以展开这个式子得到：
        f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
        当j=j-v的时候，有如下等式
        f[i , j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w , .....)
        由上两式，可得出如下递推关系：
        f[i][j]=max(f[i,j-v]+w , f[i-1][j])
        有了上面的关系，那么其实k循环可以不要了，核心代码优化成这样：

```java
    //核心代码
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= V; j++) {
//                for (int k = 0; k * v[i] <= j; k++) {
//                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);
//                }
                dp[i][j]=dp[i-1][j]; //如果不选的情况下
                if(j >= v[i])           // 可以选择第i个物品，状态方程见上面推导
                    dp[i][j]=Math.max(dp[i][j-v[i]]+w[i],dp[i][j]); //因为上面赋过值，此时可以直接写dp[i][j] 相当于dp[i-1][j]
            }
        }
```

## 优化成一维数组

```
看一下之前01背包的方程，发现是很像的
f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包

f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题
```

> 对于完全背包可以理解成因为可以选取多个元素，所以每次是可以从前i 个中选，因此有上面那个式子

同样可以用到01背包的方式优化成一维数组，不同的是从小到大枚举，因为这里要用到的是第i层的[j-v[i]]，要更新过了的。

完整代码如下

```java
import java.util.Scanner;

class Main {
    public static void main(String[] args) throws Exception {
        //***********读入数据代码开始**************
        Scanner reader = new Scanner(System.in);
        // 物品的数量为N
        int N = reader.nextInt();
        // 背包的容量为V
        int V = reader.nextInt();
        //v[i]表示第i个元素的容量,w[i]表示第i个元素的价值
        int[] v = new int[N + 1];
        int[] w = new int[N + 1];

        //这里索引从1开始，索引下标代表第i个物品
        for (int i = 1; i <= N; i++) {
            v[i] = reader.nextInt();
            w[i] = reader.nextInt();
        }
        reader.close();
        //***********读入数据代码结束**************


        int[] dp = new int[V + 1];

        //核心代码
        for (int i = 1; i <= N; i++) {
            for (int j = v[i]; j <=V ; j++) {
                    dp[j]=Math.max(dp[j-v[i]]+w[i],dp[j]);
            }
        }
        System.out.println(dp[V]); //最后dp[n][v]就表示从前n个元素中选，体积不超过m的价值的最大值

    }
}
```

## lintcode 440

https://www.lintcode.com/problem/440/

### 二维数组

```java
public class Solution {
    /**
     * @param A: an integer array
     * @param V: an integer array
     * @param m: An integer
     * @return: an array
     */
    public int backPackIII(int[] A, int[] V, int m) {
        // write your code here
        int n=A.length;
        int dp[][]=new int[n+1][m+1];

        for (int i=1;i<=n;i++){
            for (int j=0;j<=m;j++){
                dp[i][j]=dp[i-1][j];
                if (j>=A[i-1]){
                    dp[i][j]=Math.max(dp[i][j],dp[i][j-A[i-1]]+V[i-1]);
                }
            }
        }
        return dp[n][m];
    }
}
```

### 一维数组

```java
public class Solution {
    /**
     * @param A: an integer array
     * @param V: an integer array
     * @param m: An integer
     * @return: an array
     */
    public int backPackIII(int[] A, int[] V, int m) {
        // write your code here
        int n=A.length;
        int dp[]=new int[m+1];

        for (int i=1;i<=n;i++){
            for (int j=A[i-1];j<=m;j++){
                    dp[j]=Math.max(dp[j],dp[j-A[i-1]]+V[i-1]);
            }
        }
        return dp[m];
    }
}
```

