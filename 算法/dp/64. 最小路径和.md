```java
package com.fisec.vpn.util;


import java.util.Arrays;


//二维网格，求从左上角到右下角的最短路径长度
//dp[i][j] 表示从[0,0]位置到[i,j]位置的最短路径长度
class Solution {
    public int minPathSum(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int dp[][]=new int[m][n];
        //每次只能向下或者向右移动一步
        //base case
        dp[0][0]=grid[0][0];
        for (int i = 1; i < m; i++) {
            dp[i][0]=grid[i][0]+dp[i-1][0];
        }
        for (int i = 1; i < n; i++) {
            dp[0][i]=grid[0][i]+dp[0][i-1];
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                //只能从上个或者左边的得到，取min
                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }

        return dp[m-1][n-1];
    }
}
//因为只和i-1有关，所以可以压缩成1维
class Solution2 {
    public int minPathSum(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int dp[]=new int[n];
        //每次只能向下或者向右移动一步
        //base case
        dp[0]=grid[0][0];
//        for (int i = 1; i < m; i++) {
//            dp[0]=grid[i][0]+dp[0];
//        }
        for (int i = 1; i < n; i++) {
            dp[i]=grid[0][i]+dp[i-1];
        }

        for (int i = 1; i < m; i++) {
            dp[0]=grid[i][0]+dp[0];
            for (int j = 1; j < n; j++) {
                //只能从上个或者左边的得到，取min
                dp[j]=Math.min(dp[j],dp[j-1])+grid[i][j];
            }
        }

        return dp[n-1];
    }
}

```
