```java
package com.fisec.vpn.util;


import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;


//回溯
class Solution3 {
    int res = 0;

    public int findTargetSumWays(int[] nums, int target) {
        dfs(nums, target, 0, 0);
        return res;
    }

    private void dfs(int[] nums, int target, int sum, int i) {

        if (i == nums.length) {
            if (sum == target) {
                res++;
            }
            return;
        }

        dfs(nums, target, sum + nums[i], i + 1);
        dfs(nums, target, sum - nums[i], i + 1);
    }
}

/**
  动态规划
  原问题等同于： 找到nums一个正子集P和一个负子集N，使得总和等于target。即sum(P) - sum(N) == target，
  即2 * sum(P) == target + sum(nums)， 其中target + sum(nums)必须>=0且为偶数，否则等式不可能成立。
  则问题转换为：存在多少个子集P，使sum(P) == (target + sum(nums))/2。
   对应背包问题 dp[i][j] = x 表示，若只在前 i 个物品中选择，若当前背包的容量为 j，则最多有 x 种方法可以恰好装满背包。
  对应dp[i][j]表示前i个元素有多少个目标和为j的子集。dp[0][0] = 1
  1. dp[i][j] = dp[i-1][j]
  2. 如果nums[0...i-2]存在目标和为j-nums[i-1]的子集，则dp[i][j] += dp[i-1][j-nums[i-1]]
 */
class Solution {

    int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int n : nums) sum += n;
        // 这两种情况，不可能存在合法的子集划分
        if (target+sum<0 || ((target+sum)&1)==1) return 0;  // 必须>=0且为偶数
        return subsets(nums, (sum + target) / 2);
    }

    /* 计算 nums 中有几个子集的和为 sum */
    int subsets(int[] nums, int sum) {
        int n = nums.length;
        int[][] dp = new int[n + 1][sum + 1];
        // base case
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                if (j >= nums[i - 1]) {
                    // 背包空间充足，两种选择的结果之和
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
                } else {
                    // 背包的空间不足，只能选择不装物品 i
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][sum];
    }

}

//一维dp
class Solution2 {

    int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int n : nums) sum += n;
        // 这两种情况，不可能存在合法的子集划分
        if (target+sum<0 || ((target+sum)&1)==1) return 0;  // 必须>=0且为偶数
        return subsets(nums, (sum + target) / 2);
    }


    /* 计算 nums 中有几个子集的和为 sum */
    int subsets(int[] nums, int sum) {
        int n = nums.length;
        int[] dp = new int[sum + 1];
        // base case
        dp[0] = 1;

        for (int i = 1; i <= n; i++) {
            // j 要从后往前遍历
            for (int j = sum; j >= 0; j--) {
                // 状态转移方程
                if (j >= nums[i-1]) {
                    dp[j] = dp[j] + dp[j-nums[i-1]];
                } else {
                    dp[j] = dp[j];
                }
            }
        }
        return dp[sum];
    }

}
```
