---
title: 0-1背包
tags:
  - 动态规划
categories:
  - 算法
cover: 'https://image.imxyu.cn/file/Logo_01%E8%83%8C%E5%8C%85-100-480x480px.png'
description: 动态规划-01背包问题
abbrlink: aa4ce590
date: 2021-12-07 16:28:43
---

## 0-1 背包介绍

有 N 件物品和一个容量为 V 的背包，每件物品有各自的价值**且只能被选择一次**，要求在有限的背包容量下，装入的物品总价值最大。

「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。

动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i 个物品的做出决策，「0-1」正好代表不选与选两种决定。

> 特点：每个物品最多只能选择1次，可以不选

## 二维

![Snipaste_2019-09-13_17-06-58.png](https://image.imxyu.cn/file/1833_e192f0d8d6-Snipaste_2019-09-13_17-06-58.png)

（1）状态f [i] [j]定义：在前 i 个物品中选，背包容量 <=j 下的最优解（最大价值）：

当前的状态依赖于之前的状态，可以理解为从初始状态f [0] [0] = 0开始决策，有 N 件物品，则需要 N 次决 策，每一次对第 i 件物品的决策，状态f [i] [j]不断由之前的状态更新而来。
（2）当前背包容量不够（j < v[i]），没得选，因此前 i 个物品最优解即为前 i−1 个物品最优解：

对应代码:

```
f[i][j] = f[i - 1][j]
```

（3）当前背包容量够，可以选，因此需要决策选与不选第 i 个物品：

```
选：f[i][j] = f[i - 1][j - v[i]] + w[i]。
    
    f[i-1][j-v[i]]+w[i]:选第i个物品的集合,但是直接求不容易求所在集合的属性,这里迂回打击一下,先将第i个物品的体积减去,求剩下集合中选法的最大值.
    
不选：f[i][j] = f[i - 1][j] 。
    
我们的决策是如何取到最大价值，因此以上两种情况取 max() 。
```

状态计算中，集合划分原则：

一般原则:不重不漏,不重不一定都要满足(一般求个数时要满足)

如何将现有的集合划分为更小的子集,使得所有子集都可以计算出来.

![image-20211207142925601](https://image.imxyu.cn/file/image-20211207142925601.png)



acwing 0-1背包代码：

https://www.acwing.com/problem/content/2/

```java
import java.util.Scanner;
class Main {
    public static void main(String[] args) throws Exception {
        //***********读入数据代码开始**************
        Scanner reader = new Scanner(System.in);
        // 物品的数量为N
        int N = reader.nextInt();
        // 背包的容量为V
        int V = reader.nextInt();
        //v[i]表示第i个元素的容量,w[i]表示第i个元素的价值
        int[] v = new int[N + 1];
        int[] w = new int[N + 1];

        //这里索引从1开始，索引下标代表第i个物品
        for (int i = 1; i <= N; i++) {
            v[i] = reader.nextInt();
            w[i] = reader.nextInt();
        }
        reader.close();
        //***********读入数据代码结束**************

        // dp[i][j] 表示从前i个元素中选，体积小于j的最大价值，
        //这里取N+1和V+1，要预留出当i=0的时候(从前0个中选)
        int[][] dp = new int[N + 1][V + 1];
        //从前0个元素中选，不管背包体积j多大，选了0个所以价值肯定为0
        //而默认数组初始化的时候就都为0，所以从i=1开始取就好
        for (int i = 1; i <= N; i++) {
            for (int j = 0; j <= V; j++) {
                if (j >= v[i]) { //如果当前物品体积比背包容量小，则要决策是否要放入该物品价值最大
                    //1、不放入该物品i得到的价值就是从前i-1中选体积小于j的，=> dp[i-1][j]
                    //2、放入该物品i的价值则是先从前[i-1]中选，要将该物品的体积先预留出来，然后加上该物品的价值即可。取两者的最大值即可
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
                } else {//如果当前物品的体积比背包的容量大，不要第i个元素 =>也就是从前[i-1]中选小于j的
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        System.out.println(dp[N][V]); //最后dp[n][v]就表示从前n个元素中选，体积不超过m的价值的最大值
    }

}


```



### lintcode-125 练习

![image-20211207135539528](https://image.imxyu.cn/file/image-20211207135539528.png)

lintcode-125 · 背包问题（二）代码：

```java
class Solution {
    public static int backPackII(int m, int[] A, int[] V) {
        // write your code here
        int n = A.length;
        //这里的dp[i][j]表示从前i个元素中选，体积不超过j的价值的最大值
        //要预留出 当i=0或j=0 。也就是从前0个元素或者背包体积为0的时候
        int dp[][] = new int[n + 1][m + 1];

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                if (j >= A[i - 1]) {
                    //这里要注意第1个元素代表A[0]，因此i对应=>A[i-1],V[i-1]
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - A[i - 1]] + V[i - 1]);
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][m];
    }

}
```

> 注意这里第i个元素，i是从1开始的，代表数组中的A[i-1]位置的元素

## 一维数组优化

acwing

```java
//一维数组优化版
public class Main {
    public static void main(String[] args) throws Exception {
        // 读入数据的代码
        Scanner reader = new Scanner(System.in);
        // 物品的数量为N
        int N = reader.nextInt();
        // 背包的容量为V
        int V = reader.nextInt();
        // 一个长度为N的数组，第i个元素表示第i个物品的体积；
        int[] v = new int[N + 1];
        // 一个长度为N的数组，第i个元素表示第i个物品的价值；
        int[] w = new int[N + 1];

        for (int i = 1; i <= N; i++) {
            // 接下来有 N 行，每行有两个整数:v[i],w[i]，用空格隔开，分别表示第i件物品的体积和价值
            v[i] = reader.nextInt();
            w[i] = reader.nextInt();
        }
        reader.close();


/*
1. dp[i] 仅用到了dp[i-1]层,    dp[i][j] = dp[i - 1][j];
2. j与j-v[i] 均小于j
因此我们可以用滚动数组（每次用上一层的值，这样就可以减少一维）来解决，可以把他看成是一维的,因为i用到的i-1层的，先更新i-1层的，而i用的就是i-1的。
3.若用到上一层的状态时,从大到小枚举（因为大的没被更新过，此时还是第i-1层的值）, 反之从小到大
因此可以直接删去一维i
*/
        int[] dp = new int[V + 1];
        for (int i = 1; i <= N; i++) {
            //这里去除之前的if判断，j直接从v[i]开始就好了
            for (int j = V; j >= v[i]; j--) {
		//   我们是一行一行更新的，因为j-v[i]是小于j的，如果j是从小到大枚举的，当到了j的时候j-v[i]肯定是被更新过了的，表示的是第i层的[i][j-v[i]]
		//   而我们要用的是[i-1]层的[j-v[i]]（要没更新过的），因此要从大到小枚举
                dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]);
            }

        }
        System.out.println(dp[V]);
    }
}
```

### lintcode-125

```java

class Solution {
    public  int backPackII(int m, int[] A, int[] V) {
        // write your code here
        int n = A.length;
        //这里的dp[i][j]表示从前i个元素中选，体积不超过j的价值的最大值
        //要预留出 当i=0或j=0 。也就是从前0个元素或者背包体积为0的时候
        int dp[] = new int[m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= A[i - 1]; j--) {
                //这里要注意第1个元素代表A[0]，因此i对应=>A[i-1],V[i-1]
                dp[j] = Math.max(dp[j], dp[j - A[i - 1]] + V[i - 1]);
            }
        }
        return dp[m];
    }

}
```

