```java
package com.fisec.vpn.util;


//最长回文子序列
//dp[i][j] 定义为[i,j]的最长回文串
//假设已经知道了i+1,j-1 。那么 i,j做选择
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // dp 数组全部初始化为 0
        int[][] dp = new int[n][n];
        // base case 如果只有一个字符，也就是i==j的时候长度为1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        // 因为需要i+1,j  i+1,j-1 i,j-1的值。反着遍历保证正确的状态转移
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) { //因为当i<j是没有意义的
                // 状态转移方程
                if (s.charAt(i) == s.charAt(j)) { //如果相等的话长度加2
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); //选择将i+1和j-1二者其一的最大值
                }
            }
        }
        // 整个 s 的最长回文子串长度
        return dp[0][n - 1];
    }
}

//一维数组优化
class Solution2 {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // dp 数组全部初始化为 0
        int[] dp = new int[n];
        // base case 如果只有一个字符，也就是i==j的时候长度为1
        for (int i = 0; i < n; i++) {
            dp[i] = 1;
        }
        // 因为需要i+1,j  i+1,j-1 i,j-1的值。反着遍历保证正确的状态转移
        for (int i = n - 1; i >= 0; i--) {
            int upLeft=0; //用来保存上一层的值
            for (int j = i + 1; j < n; j++) { //因为当i<j是没有意义的
                // 状态转移方程
                int temp=dp[j];
                if (s.charAt(i) == s.charAt(j)) { //如果相等的话长度加2
                    dp[j] = upLeft + 2;
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]); //选择将i+1和j-1二者放入其一的最大值
                }
                upLeft=temp;
            }

        }
        // 整个 s 的最长回文子串长度
        return dp[n - 1];
    }
}

//另一种思路：先将字符串反转，然后找二者的公共子序列
class Solution3 {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length() + 1][s.length() + 1];
        String s1 = reverse(s);
        for(int i = 1; i <= s.length(); i++){
            for(int j = 1; j <= s1.length(); j++){
                if(s.charAt(i - 1) == s1.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[s.length()][s1.length()];
    }

    public String reverse(String s){
        char[] ch = s.toCharArray();
        int i = 0;
        int j = s.length() - 1;
        while(i <= j){
            char temp = ch[i];
            ch[i] = ch[j];
            ch[j] = temp;
            i++;
            j--;
        }
        return new String(ch);
    }
}
```
