```java
package com.fisec.vpn.util;


import java.util.Arrays;



//1、二分+贪心 纸牌堆
class Solution {
    public int lengthOfLIS(int[] nums) {

        int[] res = new int[nums.length];
        res[0] = nums[0];
        // res数组中加入的序列长度
        int len = 1;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > res[len - 1]) { //如果大于，则重新开一堆
                res[len++] = nums[i];
            } else if (nums[i] < res[len - 1]) { //如果小于的话，二分查找牌堆中大于这个数的最小值,进行替换
                // 二分查找，数组中大于nums[i]的最小值
                int index = binarySearch(res, 0, len - 1, nums[i]);
                res[index] = nums[i];
            }//等于就不用操作了
        }
        return len;
    }

    /**
     * 二分查找大于等于data的最小值，这里如果等于的话也做一次更新
     */
    public int binarySearch(int[] res, int left, int right, int data) {

        while (left < right) {
            int mid = (left + right) / 2;
            if (res[mid] > data) {
                right = mid;
            } else if (res[mid] < data) {
                left = mid + 1;
            }
        }
        return left;
    }

}

//2、dp
//dp[i]表示[0,i]的最长递增子序列
class Solution2 {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int maxans=1;
        for (int i = 0; i < nums.length; i++) {
            for (int j = i; j >= 0; j--) {//找比当前值小的子序列
                if (nums[i] > nums[j]) { //必须大于nums[j]才能加到后面形成更长的子序列，相等的话最长的还是之前的就不用比较了
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxans = Math.max(maxans, dp[i]);
        }

        return maxans;
    }
}


```
