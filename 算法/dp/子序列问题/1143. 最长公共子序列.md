```java
package com.fisec.vpn.util;


//最长公共子序列
//dp[i][j]表示到i、j结尾的两个字符串的最长公共子序列长度
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
//        basecase为两个字符串长度为0的情况下，这时候需要偏移，数组长度为len+1.空余出basecase
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1]; //此时肯定在公共序列中
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);//此时肯定有一个不在公共队列中

                }
            }
        }
        return dp[m][n];
    }
}

//二维数组压缩成一维数组，因为这里既用到了上一层的i-1,j-1 又用到了i,j-1 。 所以应该将上一层的值保存下来
class Solution2 {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
//        basecase为两个字符串长度为0的情况下，这时候需要偏移，数组长度为len+1.空余出basecase
        int[] dp = new int[n + 1];
        for (int i = 1; i <= m; i++) {
            int upLeft = dp[0];
            for (int j = 1; j <=n; j++) {
                int tmp = dp[j];//记录未被覆盖之前的dp[j], 它会在计算 j+1的时候作为upLeft用到
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
//                    dp[j] = 1 + dp[j - 1];  这里会被覆盖，所以要保存一下
                    dp[j] = upLeft+1;
                } else {
                    dp[j] = Math.max(dp[j - 1], dp[j]);//此时肯定有一个不在公共队列中
                }
                upLeft=tmp;
            }
        }
        return dp[n];
    }
}

```
