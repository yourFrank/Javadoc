```java
package com.fisec.vpn.util;


import java.util.Arrays;


//从src到达dst的价格最便宜，最多经过k个中转
//dp[k][i] 表示通过k个中转到达i的最低价格  。动态规划
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        final int INF = 10000 * 101 + 1;
        //因为k=0 也是有这个值的，所以要再多预留出一个
        int dp[][] = new int[k + 2][n + 1];
        // 首先初始化所有的为最大值
        for (int i = 0; i < k + 2; ++i) {
            Arrays.fill(dp[i], INF);
        }
        //base case, 从目的地出发价格为0
        dp[0][src] = 0;
        for (int t = 1; t <= k + 1; ++t) {
            for (int[] flight : flights) {
                int j = flight[0], i = flight[1], cost = flight[2];
                dp[t][i] = Math.min(dp[t][i], dp[t - 1][j] + cost); // dp[t - 1][j] + cost 表示留出1个中转+上这个中转的花费
            }
        }
        int ans = INF;
        for (int t = 1; t <= k + 1; ++t) {
            ans = Math.min(ans, dp[t][dst]);
        }
        return ans == INF ? -1 : ans;

    }
}

//DFS+记忆化搜索
class Solution2 {

    int INF = 1000007;

    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        // k表示经过的节点，我们转成边数（步数），这样好计算一些
        int[][] memo = new int[n][k + 2];
        int ans = dfs(flights, src, dst, k + 1, memo);
        return ans >= INF ? -1 : ans;
    }

    // 表示从 i 到 dst 的走 k 步的最小价格
    private int dfs(int[][] flights, int i, int dst, int k, int[][] memo) {
        if (k < 0) {
            return INF;
        }

        if (i == dst) {
            return 0;
        }

        if (memo[i][k] != 0) {
            return memo[i][k];
        }

        int min = INF;
        for (int[] flight : flights) {
            // 遍历 i 的下一个节点
            if (flight[0] == i) {
                min = Math.min(min, dfs(flights, flight[1], dst, k - 1, memo) + flight[2]);
            }
        }

        memo[i][k] = min;

        return min;
    }
}
```
