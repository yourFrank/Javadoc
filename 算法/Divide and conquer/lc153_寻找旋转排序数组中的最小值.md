```java





//分治，左边的最小值，和右边最小值取min Tn=O(logn)
class Solution {
    public int findMin(int[] nums) {
        return findMin(nums, 0, nums.length - 1);
    }

    private int findMin(int[] nums, int l, int r) {
        //如果剩下一个或者两个元素，选取其中的最小值
        if (l + 1 >= r) return Math.min(nums[l], nums[r]);
        // Sorted,则返回开始的元素l即可
        if (nums[l] < nums[r]) return nums[l];
        int mid = (r - l >> 1) + l;
        return Math.min(findMin(nums, l, mid), findMin(nums, mid + 1, r));
    }
}


/**
 * 二分  Tn=O(logn)
 * 有单调区间，首先要想到二分，这题使用二分区间选择，总共就有两种情况
 *        右               中                           中
 *1.    中         2.  左                 3.（不存在）      右   因为是递增区间这种情况不存在的
 *    左                       右                   左
 *
 *    因此只有1、2两种情况，我们可以每次二分的时候中间节点和右节点比较。舍弃区间。不能和左边比较没法判断
 */

class Solution2 {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (nums[pivot] < nums[high]) {
                high = pivot;
            } else {
                low = pivot + 1;
            }
        }
        return nums[low];
    }
}
```
