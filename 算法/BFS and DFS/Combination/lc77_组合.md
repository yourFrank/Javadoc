```java
package com.fisec.vpn.util;

import java.util.*;
import java.util.stream.Collectors;


class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res=new ArrayList<>();
        LinkedList<Integer> path=new LinkedList<>();
        dfs(n,k,res,path,1);
        return res;
    }

    private void dfs(int n, int k, List<List<Integer>> res,LinkedList<Integer> path, int begin) {
        if (path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i <= n; i++) {
            path.add(i);
            //因为不允许出现重复元素，从i+1开始
            dfs(n,k,res,path,i+1);
            path.removeLast();
        }

    }
}

/**
 * 剪枝操作，可以根据k决定取元素的上界。比如n=5，k=3 ，那么第一层从4向后的就不用取了，最多到【3，4,5】
 * 搜索起点的上界 + 接下来要选择的元素个数 - 1 = n
 * 接下来要选的元素个数=k-path.size()
 * k和pathSize有关
 */
class Solution_better {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res=new ArrayList<>();
        LinkedList<Integer> path=new LinkedList<>();
        dfs(n,k,res,path,1);
        return res;
    }

    private void dfs(int n, int k, List<List<Integer>> res,LinkedList<Integer> path, int begin) {
        if (path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        // 只有这里 i <= n - (k - path.size()) + 1 与参考代码 1 不同
        for (int i = begin; i <= n - (k - path.size()) + 1 ; i++) {
            path.add(i);
            //因为不允许出现重复元素，从i+1开始
            dfs(n,k,res,path,i+1);
            path.removeLast();
        }

    }
}



```
