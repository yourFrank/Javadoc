---
title: 二叉树的遍历
tags:
  - 算法
categories:
  - 算法
cover: 'https://image.imxyu.cn/file/2tree.jpg'
description: 二叉树的遍历
abbrlink: ea4681d0
date: 2021-12-10 13:41:43
---

> 建议按照这个顺序来做和思考，递归遍历不写了，这里说一下迭代写法

## 中序遍历lc - 94

因为中序遍历的顺序是左中右，因此我们先将左子树全都压入到栈。然后依次弹出后的元素加入到list，然后加入其右子树即可。这样就是左中右的顺序了

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }
		
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        while (!stack.isEmpty()||root!=null){
            //左子树全压入栈
            while (root!=null){
                stack.push(root);
                root=root.left;
            }
            root = stack.pop();
            res.add(root.val);
            root= root.right;

        }

        return res;
    }
}
```

> 此处建议使用Deque双端队列，已经不建议使用java的Stack，因为stack类继承Vector，stack可以操作数组中的任意元素的添加和查询，比如使用add方法，在指定一个索引添加元素。
>
> 而我们的stack添加元素只能在栈顶添加。因此在个继承关系是不合理的，应该当初设计为组合关系。所以我们以后用Deque双端队列替代（deque还是有一些问题可以在两头添加，这里不作讨论了）

## 后序遍历lc -145

代码一：

与中序的不同之处在于：

- 中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。
- 后序遍历中，因为我们要按照左右中的顺序访问，当从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。

因此我们要记录右子树是否访问过，我们在后序遍历中，引入了一个prev来记录历史访问记录。

- 当访问完一棵子树的时候，我们用prev指向该节点。
- 这样，在回溯到父节点的时候，我们可以依据prev是指向左子节点，还是右子节点，来判断父节点的访问情况。

```java
class Solution{
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans=new LinkedList<>();
        Stack<TreeNode> stack=new Stack<>();
        TreeNode prev=null;
        //主要思想：
        //由于在某颗子树访问完成以后，接着就要回溯到其父节点去
        //因此可以用prev来记录访问历史，在回溯到父节点时，可以由此来判断，上一个访问的节点是否为右子树
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            //从栈中弹出的元素,在这之前都是和中序遍历相同的操作
            root=stack.pop();
            //现在需要确定的是是否有右子树，或者右子树是否访问过。开始时prev指向最左边的节点
            //如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时
            //说明可以访问当前节点
            if(root.right==null||root.right==prev){
                ans.add(root.val);
                //更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成
                prev=root;
                root=null;
            }else{
                //如果右子树没有被访问，那么将当前节点压栈，先去访问右子树
                stack.push(root);
                root=root.right;
            }
        }
        return ans;
    }
}
```

代码二：

1. 前序遍历的过程 是 中左右。
2. 将其转化成 中右左。也就是压栈的过程中优先压入左子树，在压入右子树。
3. 然后将这个结果返回来，这里是利用栈的先进后出倒序打印/加入到list
4. （这种比较好理解）

```java
class Solution {

    public List<Integer> postorderTraversal(TreeNode head) {
        List<Integer> list=new ArrayList<>();
        if (head == null) {
            return list;
        }
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        stack1.push(head);
        while (!stack1.isEmpty()) {
            TreeNode node = stack1.pop();
            stack2.push(node);
            if (node.left != null) {
                stack1.push(node.left);
            }
            if (node.right != null) {
                stack1.push(node.right);
            }
        }
        while (!stack2.isEmpty()) {
            list.add(stack2.pop().val);
        }
        return list;
    }

}
```

代码二改进：使用linkedlist方法不用再遍历，直接addFirst（）方法就相当于倒序了（推荐这种）

```java
class Solution {

    public List<Integer> postorderTraversal(TreeNode head) {

        Deque<TreeNode> stack = new LinkedList<>();
        LinkedList<Integer> list = new LinkedList<>();
        if (head == null) {
            return list;
        }
//        Stack<TreeNode> stack2 = new Stack<>();
        stack.push(head);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            list.addFirst(node.val);
            if (node.left != null) {
                stack.push(node.left);
            }
            if (node.right != null) {
                stack.push(node.right);
            }
        }
        return list;
    }
}
```



## 前序遍历 lc -144

这个没什么好说的，和中序遍历的区别就是入栈前先加入到list

看代码：

写法一：先添加再pop

```java

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        while (!stack.isEmpty() || root != null) {
            //中左右的顺序，入栈前先将当前元素加入到list
            while (root != null) {
                res.add(root.val);
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            root = root.right;

        }

        return res;
    }
}
```

写法二，先pop再添加(更习惯写这种)

```java
public static void preOrderIteration(TreeNode head) {
	if (head == null) {
		return;
	}
	Stack<TreeNode> stack = new Stack<>();
	stack.push(head);
	while (!stack.isEmpty()) {
		TreeNode node = stack.pop();
		System.out.print(node.value + " ");
		if (node.right != null) {
			stack.push(node.right);
		}
		if (node.left != null) {
			stack.push(node.left);
		}
	}
}

```

