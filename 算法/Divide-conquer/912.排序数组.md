```java
package com.fisec.vpn.util;

//quick sort
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    private void quickSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }
        int pivot = (l + r) / 2;//这个元素在移动交换的过程中可能会改变，因此这里要保存对应的值，而不是索引
        int i = l - 1, j = r + 1;
        while (i < j) {
            do i++; while (nums[i] < nums[pivot]);
            do j--; while (nums[j] > nums[pivot]);
            if (i < j) {
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
            }
        }
        quickSort(nums, l, j);
        quickSort(nums, j + 1, r);
    }
}

//归并排序
class Solution2 {

    public int[] sortArray(int[] nums) {

        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }

    void mergeSort(int nums[], int l, int r) {
        if (l >= r) return;
        int mid = l + r >> 1;

        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);

        int[] tmp = new int[r - l + 1]; //临时数组
        int k = 0, i = l, j = mid + 1;

        //归并过程当有一个不满足就退出循环
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) tmp[k++] = nums[i++];
            else tmp[k++] = nums[j++];
        }
        //如果两边有任意一边没放完，就继续全部添加到tmp，下面两个while只会有一个执行
        while (i <= mid) tmp[k++] = nums[i++];
        while (j <= r) tmp[k++] = nums[j++];

        //临时数组中的放回去,原数组从l开始，tmp从0开始
        for (i = l, j = 0; i <= r; i++, j++) nums[i] = tmp[j];
    }

}



```
