---
title: 4、后置增强器
tags:
  - spring源码
categories:
  - spring
  - spring源码
cover: >-
  https://image.imxyu.cn/file/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.jpg
description: 三种增强器：BeanFactoryProcessor、BeanPostProcessor、initailizingBean
abbrlink: 63813ffa
date: 2021-12-08 21:28:43
---



# 三种增强器

这节我们来一下三种增强器BeanFactoryProcessor、BeanPostProcessor、InitializingBean

> 注意：后置处理器并不只是一个工作完成后执行，还可以在前面执行。

## BeanFactoryProcessor

**BeanFactory**的后置增强器有两个

* **BeanFactoryPostProcessor**：对BeanFactory的后置增强
* **BeanDefinitionRegistryPostProcessor:Bean**定义信息的后置增强

spring中都是面向接口的，底下都是多态实现，因此我们只用看接口就行

![image-20211208190828104](https://image.imxyu.cn/file/image-20211208190828104.png)

可以看到BeanFactoryPostProcessor 可以接收一个beanFactory，对bean工厂后置增强

![image-20211219145043488](https://image.imxyu.cn/file/image-20211219145043488.png)

子类还有一个接口，这个接口是对bean定义注册中心（图纸库）的后置增强

![image-20211219150615096](https://image.imxyu.cn/file/image-20211219150615096.png)

接下来我们写两个类实现这两个接口，看看他们的工作

### 断点1.1-每个BeanFactory后置处理器

```java
/**
 * BeanFactory的后置处理器
 */
@Component
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
   public MyBeanFactoryPostProcessor(){
      System.out.println("MyBeanFactoryPostProcessor...");
   }
   @Override
   public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      System.out.println("BeanFactoryPostProcessor....postProcessBeanFactory==>"+beanFactory);
   }
}
```

```java
/**
 * BeanFactory的后置处理器  , PriorityOrdered, Ordered
 */
@Component
public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {
	public MyBeanDefinitionRegistryPostProcessor(){
		System.out.println("MyBeanDefinitionRegistryPostProcessor");
	}
	@Override  //紧接着执行
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		System.out.println("MyBeanDefinitionRegistryPostProcessor....postProcessBeanFactory...");
	}

	@Override  //先执行的
	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
		System.out.println("MyBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry...");
		//增强bean定义信息的注册中心，比如自己注册组件

	}

}

```

我们建两个类分别实现BeanFactoryPostProcessor接口和BeanDefinitionRegistryPostProcessor接口

> 断点1.1、1.2、1.3先一起打上，debug看注释，然后打断点4看

![image-20211208203559335](https://image.imxyu.cn/file/image-20211208203559335.png)

## BeanPostProcessor

上一节我们看了**BeanPostProcessor**的很多子类对bean的增强，BeanPostProcessor是Bean的后置处理器，用来增强组件。每一个子接口的增强器在何时运行，**在于改变**（比如@AutowiredPostProcessor在于改变自动装配的属性值）

参数传入bean，对bean进行增强

![image-20211219145827211](https://image.imxyu.cn/file/image-20211219145827211.png)

**BeanPostProcessor**的后置处理器还有很多，都是对Bean的增强

![image-20211219151236357](https://image.imxyu.cn/file/image-20211219151236357.png)

> 其中DestructionAwareBeanPostProcessor 是和销毁有关的，POBBP是自己测试的。这俩不用管

同样我们写几个类来实现BeanPostProcessor的这几个接口

### 断点1.2-每个Bean后置处理器

```java
/**
 * Bean组件的 PostProcessor；
 */
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
	public MyBeanPostProcessor(){
		System.out.println("MyBeanPostProcessor...");
	}
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("MyBeanPostProcessor...postProcessAfterInitialization..."+bean+"==>"+beanName);
		return bean;
	}
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("MyBeanPostProcessor...postProcessBeforeInitialization..."+bean+"==>"+beanName);
		return bean; // new Object();
	}


}
```

```java
@Component
public class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
	public MyInstantiationAwareBeanPostProcessor(){
		System.out.println("MyInstantiationAwareBeanPostProcessor...");
	} //初始化之前进行后置处理，Spring留给我们给这个组件创建对象的回调。
	public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
		System.out.println("MyInstantiationAwareBeanPostProcessor...postProcessBeforeInstantiation=>"+beanClass+"--"+beanName); //if(class.isAssFrom(Cat.class)){return new Dog()}
		return null; //如果我们自己创建了对象返回。Spring则不会帮我们创建对象，用我们自己创建的对象？ 我们创建的这个对象，Spring会保存单实例？还是每次getBean都调到我们这里创建一个新的？
	}
	public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
		System.out.println("MyInstantiationAwareBeanPostProcessor...postProcessAfterInstantiation=>"+bean+"--"+beanName); //提前改变一些Spring不管的bean里面的属性
		return true; //返回false则bean的赋值全部结束
	}  //解析自定义注解进行属性值注入；pvs 封装了所有的属性信息。
	public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)
			throws BeansException { //@GuiguValue();redis
		System.out.println("MyInstantiationAwareBeanPostProcessor...postProcessProperties=>"+bean+"--"+beanName);
		return null;
	}
//	public PropertyValues postProcessPropertyValues(
//			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
//		System.out.println("MyInstantiationAwareBeanPostProcessor...postProcessProperties");
//		return pvs;
//	}
}
```

```java
@Component
public class MyMergedBeanDefinitionPostProcessor implements MergedBeanDefinitionPostProcessor {
	public MyMergedBeanDefinitionPostProcessor(){
		System.out.println("MyMergedBeanDefinitionPostProcessor...");
	}

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("MyMergedBeanDefinitionPostProcessor...postProcessBeforeInitialization...=>"+bean+"--"+beanName);
		return bean; //null
	}

	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("MyMergedBeanDefinitionPostProcessor...postProcessAfterInitialization..=>"+bean+"--"+beanName);
		return null;
	}

	@Override
	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
		System.out.println("MyMergedBeanDefinitionPostProcessor...postProcessMergedBeanDefinition..=>"+beanName+"--"+beanType+"---"+beanDefinition);
	}

	@Override
	public void resetBeanDefinition(String beanName) {
		System.out.println("MyMergedBeanDefinitionPostProcessor...resetBeanDefinition.."+beanName);

	}
}
```

```java
@Component   //bean进行代理增强期间进行使用
public class MySmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor {

	public MySmartInstantiationAwareBeanPostProcessor(){
		System.out.println("MySmartInstantiationAwareBeanPostProcessor...");
	}  //预测bean的类型，最后一次改变组件类型。
	public Class<?> predictBeanType(Class<?> beanClass, String beanName) throws BeansException {
		System.out.println("MySmartInstantiationAwareBeanPostProcessor...predictBeanType=>"+beanClass+"--"+beanName);
		return null;
	}
    //返回我们要使用的构造器候选列表
	public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, String beanName)

			throws BeansException {
		System.out.println("MySmartInstantiationAwareBeanPostProcessor...determineCandidateConstructors=>"+beanClass+"--"+beanName);
		//返回一个我们指定的构造器
		return null;
	}
     //返回早期的bean引用，定义三级缓存中的bean信息
	public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
		System.out.println("MySmartInstantiationAwareBeanPostProcessor...getEarlyBeanReference=>"+bean+"--"+beanName);

		return bean; //
	}

}
```



接下来我们实现所有的Bean后置处理器，看这些后置处理器是怎么工作的

![image-20211208192748341](https://image.imxyu.cn/file/image-20211208192748341.png)



![image-20211208192835305](https://image.imxyu.cn/file/image-20211208192835305.png)



剩下那两个类也是同样，在每个方法上打断点

### 断点1.3-cat对象set赋值

接下来我们只用注解创建一个Cat对象（其他对象注解@Component取消），并且在对象set赋值的时候打断点

![image-20211208193359439](https://image.imxyu.cn/file/image-20211208193359439.png)

创建beans2.xml，只注册了cat对象和所有processor组件

![image-20211208193845168](https://image.imxyu.cn/file/image-20211208193845168.png)

使用xml方式进行debug

![image-20211208194012304](https://image.imxyu.cn/file/image-20211208194012304.png)

## 后置处理器流程

### BeanDefinitionRegistryPostProcessor

#### BeanDefinitionRegistryPostProcessor组件创建

首先断点来到了这里，我们从第一个栈开始看

![image-20211219161523358](https://image.imxyu.cn/file/image-20211219161523358.png)

这几个就不用解释了，之前看过好多遍了

![image-20211219161725472](https://image.imxyu.cn/file/image-20211219161725472.png)

![image-20211219161729939](https://image.imxyu.cn/file/image-20211219161729939.png)

![image-20211219161736913](https://image.imxyu.cn/file/image-20211219161736913.png)

在工厂创建之后，调用了工厂的后置处理器对工厂进行增强

![image-20211219162022551](https://image.imxyu.cn/file/image-20211219162022551.png)

执行所有的工厂后置增强器

![image-20211219193815322](https://image.imxyu.cn/file/image-20211219193815322.png)

接下来这个方法比较长，我把这个方法截成三张图看一下

首先会拿到底层默认有的BeanDefinitionRegistryPostProcessor，不是我们实现的，这里没有![image-20211219195327343](https://image.imxyu.cn/file/image-20211219195327343.png)

接下来会1、拿到类型是BeanDefinitionRegistryPostProcessor，并且实现了PriorityOrdered接口的，按照定义的优先级排序后添加到集合

​				2、拿到类型是BeanDefinitionRegistryPostProcessor，并且实现了Ordered接口的，按照定义的优先级排序后添加到集合（这里注意如果有PriorityOrdered接口了在上面处理过了这里就不会处理了）

![image-20211219195745014](https://image.imxyu.cn/file/image-20211219195745014.png)

3、然后才拿到没有实现任何优先级和排序接口的BeanDefinitionRegistryPostProcessor类型，此时如果有多个该类型，会按照类名的大小写进行排序

此时我们实现的就到了这里，找到该类型后会调用getBean()方法，下面又开始了在缓存中找，没有就创建的流程，和我们之前创建普通Bean对象一样的流程。

因此我们可以看到工厂后置增强器的创建是在Bean对象创建之前的。并且spring中所有创建组件都会调用getBean()方法，先去缓存找，没有再创建

![image-20211219195944394](https://image.imxyu.cn/file/image-20211219195944394.png)

进入该getBean()就到了该对象创建的过程，下面的方法和之前创建bean的重复，就不进行介绍了，直接看图

![image-20211219200604870](https://image.imxyu.cn/file/image-20211219200604870.png)

![image-20211219200617655](https://image.imxyu.cn/file/image-20211219200617655.png)



![image-20211219200627454](https://image.imxyu.cn/file/image-20211219200627454.png)

。。。。。省略调用过程，一直到最后由简单策略反射创建对象

![image-20211219200819959](https://image.imxyu.cn/file/image-20211219200819959.png)

然后就来到了该类的构造函数中

![image-20211219200833506](https://image.imxyu.cn/file/image-20211219200833506.png)

#### postProcessBeanDefinitionRegistry（）

我们继续放行之后，来到了下面这个执行方法，在这里我们可以直接调用registry注册中心自己向工厂中注册组件

![image-20211219201151084](https://image.imxyu.cn/file/image-20211219201151084.png)

我们看看堆栈，是从哪调到这个方法的

![image-20211219201529762](https://image.imxyu.cn/file/image-20211219201529762.png)

如果有多个该类型的通过for循环执行每个BeanDefinitionRegistryPostProcessor类型的postProcessBeanDefinitionRegistry（）方法，这里我们只有一个

这样就完成了调用postProcessBeanDefinitionRegistry方法的调用

![image-20211219201618803](https://image.imxyu.cn/file/image-20211219201618803.png)

#### postProcessBeanFactory（）

我们继续放行，来到了这个方法

![image-20211219202206203](https://image.imxyu.cn/file/image-20211219202206203.png)

在这里调用了该方法，其他过程和上面一样，就不复述了

![image-20211219202311033](https://image.imxyu.cn/file/image-20211219202311033.png)

至此BeanDefinitionRegistryPostProcessor类型的后置增强就结束了

### BeanFactoryPostProcessor

#### BeanFactoryPostProcessor组件创建

然后我们继续放行，接下来来到BeanFactoryPostProcessor,该接口是刚才BeanDefinitionRegistryPostProcessor接口的父类

![image-20211221192152927](https://image.imxyu.cn/file/image-20211221192152927.png)

前面的容器刷新过程省略，我们直接来到这个getBean,该方法上面就是之前的BeanDefinitionRegistryPostProcessor（两者都在同一个方法，BeanDefinitionRegistryPostProcessor创建执行完之后，再进行BeanFactoryPostProcessor的创建执行），可以看到和之前的流程是一样的，都是可以先拿到Priority、Ordered 接口的，然后拿到普通的，调用getBean()创建BeanFactoryPostProcessor对象。创建完成之后调用方法（和上面一样）

![image-20211219204836914](https://image.imxyu.cn/file/image-20211219204836914.png)

然后就是组件创建的流程，这里省略。就来到我了我们的构造函数

![image-20211219205156508](https://image.imxyu.cn/file/image-20211219205156508.png)

继续放行就来到了方法调用，具体的调用就是上面创建完调用的过程，这里就不重复了

![image-20211219205257909](https://image.imxyu.cn/file/image-20211219205257909.png)

至此我们可以看到模板中的顺序，先工厂创建——》工厂增强（创建后置工厂处理器bean，调用相关方法） ，bean的创建还遥遥无期

![image-20211219205640731](https://image.imxyu.cn/file/image-20211219205640731.png)

### spring的BeanFactoryProcessor

我们来看看BeanFactoryProcessor的作用是什么？spring就利用了实现BeanDefinitionRegistryPostProcessor的后置处理器，来将配置类里的@Component、@ComponentScan、@Import 注解解析，将所对应的**bean定义信息**加入到工厂中



#### 断点2.1- MainConfig

因为要解析注解类，首先给MainConfig打上断点

![image-20211208212055538](https://image.imxyu.cn/file/image-20211208212055538.png)

#### 断点2.2-AbstractApplicationContext

这里是所有bean工厂的后置处理器处理的地方，给这里打上断点

![image-20211208212652068](https://image.imxyu.cn/file/image-20211208212652068.png)

**使用注解容器类启动**：进行debug

> 断点2.1 和2.2一起打上看debug源码
>
> 测试类，使用注解类测试

![image-20211208212934042](https://image.imxyu.cn/file/image-20211208212934042.png)

#### 配置类的后置处理器流程

在这里执行工厂的后置处理器

![image-20211208210554120](https://image.imxyu.cn/file/image-20211208210554120.png)

在这里获取所以有类型为**BeanDefinitionRegistryPostProcessor**，（和之前一样）可以看到spring自己定义的一个后置处理器，该processor是为了给注解的配置文件（MainConfig）注册Bean定义信息的，并且该接口实现了priorityOreder接口

![image-20211208205703478](https://image.imxyu.cn/file/image-20211208205703478.png)

---

还是按照1.priorityOrdered、2.Ordered、3.没实现排序接口的工厂后置处理器。这样的顺序开始执行

首先在实现priorityOrdered接口中找到了一个ConfigurationClassPostProcessor（）（这就是spring自己定义的，配置类的后置处理器），调用创建、执行的过程，我们点进执行的过程看一看

![image-20211219210612067](https://image.imxyu.cn/file/image-20211219210612067.png)

继续进

![image-20211219211047352](https://image.imxyu.cn/file/image-20211219211047352.png)

在这里把**配置类**中的所有**bean定义信息**导入，下面我看看看是如何导入的

![image-20211219211143925](https://image.imxyu.cn/file/image-20211219211143925.png)

首先拿到所有的bean定义信息，此时会看到有配置类的定义信息

![image-20211219212243837](https://image.imxyu.cn/file/image-20211219212243837.png)

然后判断将**配置类**的定义信息加到这个候选集合中，等待处理

![image-20211219212553828](https://image.imxyu.cn/file/image-20211219212553828.png)

如果有多个配置类， 这里会将获取的所有的**配置类**按照顺序进行排序，这里直接调用getSingleton() 用来生成一个配置类的名字（getBean底层调用的就是这个），此时配置类就会创建。

![image-20211208205242055](https://image.imxyu.cn/file/image-20211208205242055.png)

然后解析配置类中的所有注解

![image-20211208210342975](https://image.imxyu.cn/file/image-20211208210342975.png)

配置类中各个注解的解析 @Component,@ComponentScan,@Bean等。将这里面标注注解的bean定义信息都放入到档案馆中，为后面创建bean做准备

![image-20211219213825979](https://image.imxyu.cn/file/image-20211219213825979.png)

至此所有的配置类中的注解就已经解析完成，在配置类中的**bean定义信息**就已经加入到工厂中

> 因此在创建完工厂之后，就会执行配置类的解析，将所有的注解都解析完成，将在配置类中写的bean定义信息等加入到工厂，而不是在创建bean的时候再执行，否则没定义信息没法造配置类中的bean。

## BeanPostPorocessor



##　initailizingBean

还有一个Bean的生命周期处理器的接口**InitailizingBean**这个接口的功能也是Bean组件初始化以后对组件进行后续设置

BeanPostProcessor和BeanFactoryProcessor参数都是传入Bean或者BeanFactory对象，在于改变。而initailizingBean的参数是空参的，在于额外处理

![image-20211219145309093](https://image.imxyu.cn/file/image-20211219145309093.png)