---
title: 迭代器模式
tags:
  - 迭代器模式
  - 设计模式
  - 行为型
categories:
  - 设计模式
  - 行为型
  - 迭代器模式
cover: 'https://image.imxyu.cn/file/design-avater01.webp'
swiper_index: 5
description: 行为型
abbrlink: 9055d217
date: 2021-10-13 21:28:43
---

**声明：**

1、学习思路全部来自尚硅谷雷丰阳老师的教学视频

# 迭代器模式

迭代器（Iterator）模式：提供一个对象(迭代器)来顺序访问聚合对象(迭代数据)中的一系列数据，而不暴露聚合对象的内部表示。对象行为型模式

抽象聚合（Aggregate）角色：
	定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
具体聚合（ConcreteAggregate）角色：
	实现抽象聚合类，返回一个具体迭代器的实例。
抽象迭代器（Iterator）角色：
	定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
具体迭代器（Concretelterator）角色：
	实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。

![image-20211020211250830](https://image.imxyu.cn/file/image-20211020211250830.png)

```java

/**
 * 抽象聚合类
 */
public abstract class BeautifulMan {

    //不方便暴露给外界的集合。只允许外界获取而不可以操作
    private List<String> girlFriends = new ArrayList<>();

    abstract void likeYou(String name);
    abstract void sayBye(String name);

    /**
     * 获取迭代器
     * @return
     */
    public Itr getIterator(){
        return new Iterator();
    }

    /**
     * 具体迭代器
     */
    class Iterator implements Itr{
       private int cursor = 0; //当前指针
       public boolean hasNext(){
           return girlFriends.size()!=cursor;
       }

       public String next(){
           return girlFriends.get(++cursor);
       }
    }


    /**
     * 抽象迭代器，写在了内部，外部也可以
     */
    interface Itr {
        boolean hasNext();
        String next();
    }

}
```



## 使用场景

什么场景用到？
jdk容器接口的Iterator定义
现实开发中，我们几乎无需编写迭代器，基本数据结构链表、树、图的迭代器已经都有了。除非要重写迭代逻辑
......



# 责任链模式

责任链（Chain of Responsibility）模式：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。属于对象行为型模式

1. 简单责任链：

```java
//此时模拟一个找老师请假的流程
public class Teacher {
    private Teacher next; //此时就是这个链，如果换成List<Teacher> 就是组合模式
    private String  name;
    
    public void handleRequest(){
        System.out.println(this.name+"正在处理");
        if (next!=null){
            next.handleRequest();
        }
    }
}
```

2. 完整责任链:

## 模拟Filter执行

```java
public interface Filter {
    public void doFilter(Request request,Response response,FilterChain filterChain);
}
```

```java
public class FilterChain implements Filter {
    private List<Filter> list=new ArrayList<>(); //包含了所有链

    private int cursor; //定义一个游标，判断当前执行的位置

    private MyFunc target; //保存要执行方法的对象

    public List<Filter> getList() {
        return list;
    }

    public void addList(Filter filter) {
        this.list.add(filter);
    }

    public void setTarget(MyFunc target) {
        this.target = target;
    }

    public MyFunc getTarget() {
        return target;
    }

    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {

        if (cursor<list.size()){
            Filter filter = list.get(cursor); //获取当前链执行
            cursor++;//游标+1，下一次执行下一个链
            filter.doFilter(request,response,filterChain);
        }else {//当filter链结束后调用自己的方法
            target.my(); 
        }


    }
}
```

```java
public class HttpFilter implements Filter{
    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {
        System.out.println(">>>HttpFilter开始");
        filterChain.doFilter(request,response,filterChain);
        System.out.println(">>>HttpFilter结束");


    }
}
```

```java
public class EncodingFilter implements  Filter{

    @Override
    public void doFilter(Request request, Response response, FilterChain filterChain) {

        System.out.println(">>>EncodingFilter开始");
        filterChain.doFilter(request,response,filterChain);
        System.out.println(">>>EncodingFilter结束");
    }
}
```

```java
@Data
public class Request {
    private String msg;

}

@Data
public class Response {
    private  String msg;

}

```

```java
public class MyFunc {

    public void my(){
        System.out.println("my function");
    }
}
```

![image-20211020221308119](https://image.imxyu.cn/file/image-20211020221308119.png)

## 场景

什么场景用到？
Tomcat的Pipeline、Valve
Filter链
Aop责任链
......

