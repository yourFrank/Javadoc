---
title: 中介者&观察者模式
tags:
  - 中介者模式
  - 设计模式
  - 行为型
  - 观察者模式
categories:
  - 设计模式
  - 行为型
  - 中介者&观察者模式
cover: 'https://image.imxyu.cn/file/design-avater01.webp'
swiper_index: 5
description: 行为型
abbrlink: 91f4aa11
date: 2021-10-13 21:28:43
---

**声明：**

1、学习思路全部来自尚硅谷雷丰阳老师的教学视频

# 中介者模式

![image-20211020202323904](https://image.imxyu.cn/file/image-20211020202323904.png)

中介者模式(Mediator Pattern)：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，减少对象间混乱的依赖关系，从而使其耦合松散，而且可以独立地改变它们之间的交互。对象行为型模式。将网状关系变成星状关系

## 实例-飞机降落

只有一条跑道，每个飞机降落的时候需要先和各个机长确认

```java
/**
 * 抽象机长
 */
public abstract class Captain {
    //起飞
    abstract void fly();
    //降落
    abstract void land();
    //完成
    abstract void success();

}
```

```java
/**
 * 海南8778
 */
public class HU8778 extends Captain{

    ControlTower controlTower;//注意：这里塔台不能自己new，需要使用同一个塔台，也可以将塔台设置成单例

    public void setControlTower(ControlTower controlTower) {
        this.controlTower = controlTower;
    }

    @Override
    void fly() {
        System.out.println("HU8778请求起飞......");
        //问每个机长能否起飞？
        controlTower.acceptRequest(this,"fly");
    }

    @Override
    void land() {
        System.out.println("HU8778请求降落......");
        controlTower.acceptRequest(this,"land");
    }

    @Override
    void success() {
        System.out.println("完成......");
        controlTower.acceptRequest(this,"success");
    }
}
```

```java
/**
 * 四川8633机长
 */
public class SC8633 extends Captain{
    ControlTower controlTower ;  //注意：这里塔台不能自己new，需要使用同一个塔台，也可以将塔台设置成单例

    public void setControlTower(ControlTower controlTower) {
        this.controlTower = controlTower;
    }

    @Override
    void fly() {
        System.out.println("SC8633 请求起飞......");
        //问每个机长能否起飞？
        controlTower.acceptRequest(this,"fly");

    }

    @Override
    void land() {

        System.out.println("SC8633 请求降落......");
        //问每个机长能否起飞？
        controlTower.acceptRequest(this,";land");
    }

    @Override
    void success() {

        System.out.println("SC8633 完成......");
        //问每个机长能否起飞？
        controlTower.acceptRequest(this,"success");
    }
}
```

```java
/**
 * 塔台：中介者
 *
 * 网状变为星状
 */
public class ControlTower {


    private boolean canDo = true;

    //接受请求...
    public void acceptRequest(Captain captain,String action){
        if("fly".equals(action)||"land".equals(action)){
            //
            if(canDo == true){
                System.out.println("允许......");
                canDo = false;
            }else {
                System.out.println("不允许.....");
            }
        }
        if("success".equals(action)){ //如果完成了，将状态变成true。其他飞机可以起飞或者降落
            canDo = true;
        }


    }
}
```

```java
/**
 * 中介者：
 *
 */
public class MainTest {

    public static void main(String[] args) {
        HU8778 hu8778 = new HU8778();
        SC8633 sc8633 = new SC8633();

        ControlTower tower = new ControlTower();
        hu8778.setControlTower(tower);
        sc8633.setControlTower(tower); //使用同一个塔台，使用同一个状态

        hu8778.fly();

        hu8778.success();

        sc8633.fly();

    }
}
```

## 场景

观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。对象行为型模式



# 观察者模式

观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。对象行为型模式

![image-20211020204352460](https://image.imxyu.cn/file/image-20211020204352460.png)



## 实例-气象台

1. 气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去(比如发布到自己的网站或第三方)。
2. 需要**设计开放型** **API**，便于**其他第三方也能接入气象站获取数据**。
3. 提供温度、气压和湿度的接口
4. 测量数据更新时，要能实时的通知给第三方

#### WeatherData

```
JAVA
/**
 * 类是核心
 * 1. 包含最新的天气情况信息 
 * 2. 含有 CurrentConditions 对象
 * 3. 当数据有更新时，就主动的调用   CurrentConditions对象update方法(含 display), 这样他们（接入方）就看到最新的信息
 *
 */
public class WeatherData {
   private float temperatrue;
   private float pressure;
   private float humidity;
   private CurrentConditions currentConditions;
   //加入新的第三方

   public WeatherData(CurrentConditions currentConditions) {
      this.currentConditions = currentConditions;
   }

   public float getTemperature() {
      return temperatrue;
   }

   public float getPressure() {
      return pressure;
   }

   public float getHumidity() {
      return humidity;
   }

   public void dataChange() {
      //调用 接入方的 update
      currentConditions.update(getTemperature(), getPressure(), getHumidity());
   }

   //当数据有更新时，就调用 setData
   public void setData(float temperature, float pressure, float humidity) {
      this.temperatrue = temperature;
      this.pressure = pressure;
      this.humidity = humidity;
      //调用dataChange， 将最新的信息 推送给 接入方 currentConditions
      dataChange();
   }
}
```

#### CurrentConditions

```
JAVA
/**
 * 显示当前天气情况（可以理解成是气象站自己的网站）
 *
 */
public class CurrentConditions {
   // 温度，气压，湿度
   private float temperature;
   private float pressure;
   private float humidity;

   //更新 天气情况，是由 WeatherData 来调用，我使用推送模式
   public void update(float temperature, float pressure, float humidity) {
      this.temperature = temperature;
      this.pressure = pressure;
      this.humidity = humidity;
      display();
   }

   //显示
   public void display() {
      System.out.println("***Today mTemperature: " + temperature + "***");
      System.out.println("***Today mPressure: " + pressure + "***");
      System.out.println("***Today mHumidity: " + humidity + "***");
   }
}
```

#### Client

```
JAVA
public class Client {
  public static void main(String[] args) {
    // 创建接入方 currentConditions
    CurrentConditions currentConditions = new CurrentConditions();
    // 创建 WeatherData 并将 接入方 currentConditions 传递到 WeatherData中
    WeatherData weatherData = new WeatherData(currentConditions);

    // 更新天气情况
    weatherData.setData(30, 150, 40);

    // 天气情况变化
    System.out.println("============天气情况变化=============");
    weatherData.setData(40, 160, 20);
  }
}
```

#### 问题分析

1. 其他第三方接入气象站获取数据的问题，无法在运行时动态的添加第三方 (新浪网站)
2. 违反 ocp 原则，当加入第三方时，需要修改WeatherData代码，不利于维护。

### 观察者模式方案

#### Subject【接口】

```java
JAVA
//接口, 让WeatherData 来实现 
public interface Subject {
   
   public void registerObserver(Observer o);
   public void removeObserver(Observer o);
   public void notifyObservers();
}
```

#### Observer【接口】

```java
JAVA
//观察者接口，有观察者来实现
public interface Observer {

   public void update(float temperature, float pressure, float humidity);
}
```

#### WeatherData

```java
JAVA
public class WeatherData implements Subject {
   private float temperatrue;
   private float pressure;
   private float humidity;
   //观察者集合
   private ArrayList<Observer> observers;
   
   //加入新的第三方

   public WeatherData() {
      observers = new ArrayList<Observer>();
   }

   public float getTemperature() {
      return temperatrue;
   }

   public float getPressure() {
      return pressure;
   }

   public float getHumidity() {
      return humidity;
   }

   public void dataChange() {
      //调用 接入方的 update
      
      notifyObservers();
   }

   //当数据有更新时，就调用 setData
   public void setData(float temperature, float pressure, float humidity) {
      this.temperatrue = temperature;
      this.pressure = pressure;
      this.humidity = humidity;
      //调用dataChange， 将最新的信息 推送给 接入方 currentConditions
      dataChange();
   }

   //注册一个观察者
   @Override
   public void registerObserver(Observer o) {
      // TODO Auto-generated method stub
      observers.add(o);
   }

   //移除一个观察者
   @Override
   public void removeObserver(Observer o) {
      // TODO Auto-generated method stub
      if(observers.contains(o)) {
         observers.remove(o);
      }
   }

   //遍历所有的观察者，并通知
   @Override
   public void notifyObservers() {
      // TODO Auto-generated method stub
      for(int i = 0; i < observers.size(); i++) {
         observers.get(i).update(this.temperatrue, this.pressure, this.humidity);
      }
   }
}
```

#### CurrentConditions

```java
JAVA
public class CurrentConditions implements Observer {

   // 温度，气压，湿度
   private float temperature;
   private float pressure;
   private float humidity;

   // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式
   public void update(float temperature, float pressure, float humidity) {
      this.temperature = temperature;
      this.pressure = pressure;
      this.humidity = humidity;
      display();
   }

   // 显示
   public void display() {
      System.out.println("***Today mTemperature: " + temperature + "***");
      System.out.println("***Today mPressure: " + pressure + "***");
      System.out.println("***Today mHumidity: " + humidity + "***");
   }
}
```

#### BaiduSite

```java
JAVA
public class BaiduSite implements Observer {

  // 温度，气压，湿度
  private float temperature;
  private float pressure;
  private float humidity;

  // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式
  public void update(float temperature, float pressure, float humidity) {
    this.temperature = temperature;
    this.pressure = pressure;
    this.humidity = humidity;
    display();
  }

  // 显示
  public void display() {
    System.out.println("===百度网站====");
    System.out.println("***百度网站 气温 : " + temperature + "***");
    System.out.println("***百度网站 气压: " + pressure + "***");
    System.out.println("***百度网站 湿度: " + humidity + "***");
  }
}
```

#### Client

```java
JAVA
public class Client {

  public static void main(String[] args) {
    // TODO Auto-generated method stub
    // 创建一个WeatherData
    WeatherData weatherData = new WeatherData();

    // 创建观察者
    CurrentConditions currentConditions = new CurrentConditions();
    BaiduSite baiduSite = new BaiduSite();

    // 注册到weatherData
    weatherData.registerObserver(currentConditions);
    weatherData.registerObserver(baiduSite);

    // 测试
    System.out.println("通知各个注册的观察者, 看看信息");
    weatherData.setData(10f, 100f, 30.3f);

    weatherData.removeObserver(currentConditions);
    // 测试
    System.out.println();
    System.out.println("通知各个注册的观察者, 看看信息");
    weatherData.setData(10f, 100f, 30.3f);
  }
}
```

## 原理及应用场景剖析

**观察者模式**也被称为**发布订阅模式**（Publish-Subscribe Design Pattern）。在 GoF 的《设计模式》一书中，它的定义是这样的：

> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

1. 一般情况下，被依赖的对象叫作**被观察者**（Observable），依赖的对象叫作**观察者**（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。
2. 实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，待会我们会详细地讲到。现在，我们先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：

```java
import java.util.ArrayList;
import java.util.List;

public interface Subject {
  void registerObserver(Observer observer);

  void removeObserver(Observer observer);

  void notifyObservers(Message message);
}

public interface Observer {
  void update(Message message);
}

public class ConcreteSubject implements Subject {
  private List<Observer> observers = new ArrayList<Observer>();

  @Override
  public void registerObserver(Observer observer) {
    observers.add(observer);
  }

  @Override
  public void removeObserver(Observer observer) {
    observers.remove(observer);
  }

  @Override
  public void notifyObservers(Message message) {
    for (Observer observer : observers) {
      observer.update(message);
    }
  }
}

public class ConcreteObserverOne implements Observer {

  @Override
  public void update(Message message) {
    // TODO: 获取消息通知，执行自己的逻辑...
    System.out.println("ConcreteObserverOne is notified.");
  }
}

public class ConcreteObserverTwo implements Observer {

  @Override
  public void update(Message message) {
    // TODO: 获取消息通知，执行自己的逻辑...
    System.out.println("ConcreteObserverTwo is notified.");
  }
}

public class Demo {

  public static void main(String[] args) {
    ConcreteSubject subject = new ConcreteSubject();
    subject.registerObserver(new ConcreteObserverOne());
    subject.registerObserver(new ConcreteObserverTwo());
    subject.notifyObservers(new Message());
  }
}

```

1. 实际上，上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的。
2. 原理和代码实现都非常简单，也比较好理解，不需要我过多的解释。我们还是通过一个具体的例子来重点讲一下，什么情况下需要用到这种设计模式？或者说，这种设计模式能解决什么问题呢？
3. 假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：

```java
import java.util.ArrayList;
import java.util.List;

public interface RegObserver {
  void handleRegSuccess(long userId);
}

public class RegPromotionObserver implements RegObserver {
  private PromotionService promotionService; // 依赖注入

  @Override
  public void handleRegSuccess(long userId) {
    promotionService.issueNewUserExperienceCash(userId);
  }
}

public class RegNotificationObserver implements RegObserver {
  private NotificationService notificationService;

  @Override
  public void handleRegSuccess(long userId) {
    notificationService.sendInboxMessage(userId, "Welcome...");
  }
}

public class UserController {
  private UserService userService; // 依赖注入
  private List<RegObserver> regObservers = new ArrayList<>();

  // 一次性设置好，之后也不可能动态的修改
  public void setRegObservers(List<RegObserver> observers) {
    regObservers.addAll(observers);
  }

  public Long register(String telephone, String password) {
    // 省略输入参数的校验代码
    // 省略userService.register()异常的try-catch代码
    long userId = userService.register(telephone, password);

    for (RegObserver observer : regObservers) {
      observer.handleRegSuccess(userId);
    }

    return userId;
  }
}
```

1. 当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。
2. 不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改 RegPromotionObserver 类中 handleRegSuccess() 函数的代码，这还是违反开闭原则呀？你说得没错，不过，相对于 register() 函数来说，handleRegSuccess() 函数的逻辑要简单很多，修改更不容易出错，引入 bug 的风险更低。
3. 前面我们已经学习了很多设计模式，不知道你有没有发现，实际上，**设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。**借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。

## 基于不同应用场景的不同实现方式

1. 观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。
2. 不同的应用场景和需求下，这个模式也有截然不同的实现方式，开篇的时候我们也提到，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。
3. 之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户端。
4. 如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当 userService.register() 函数执行完成之后，我们启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1/3。
5. 那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个 handleRegSuccess() 函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实现方式，那就是基于 EventBus 来实现。今天，我们就不展开讲解了。在下一讲中，我会用一节的时间，借鉴 Google Guava EventBus 框架的设计思想，手把手带你开发一个支持异步非阻塞的 EventBus 框架。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。
6. 刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？
7. 如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如 ActiveMQ）来实现。
8. 当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。

## 场景

什么场景用到？
Spring事件机制如何实现？
Vue的双向绑定核心
响应式编程核心思想
......