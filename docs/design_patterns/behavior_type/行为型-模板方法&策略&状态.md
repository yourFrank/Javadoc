---
title: 模板&策略&状态模式
tags:
  - 模板模式
  - 设计模式
  - 策略模式
  - 状态模式
  - 行为型
categories:
  - 设计模式
  - 行为型
  - 模板&策略&状态模式
cover: 'https://image.imxyu.cn/file/design-avater01.webp'
swiper_index: 5
description: 行为型
abbrlink: 7b93df9d
date: 2021-10-13 21:28:43
---

**声明：**

1、学习思路全部来自尚硅谷雷丰阳老师的教学视频

# 模板方法

行为型模式和结构型模式一样，也分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。



![image-20211020193747060](https://image.imxyu.cn/file/image-20211020193747060.png)

![image-20211020193809913](https://image.imxyu.cn/file/image-20211020193809913.png)

```java

/**
 * 1、定义模板
 */
public abstract class CookTemplate {

    /**
     * 定义算法：  定义好了模板
     * 父类可以实现某些步骤
     * 留关键给子类
     */
    public void cook(){
        //定义算法步骤
        heating();   //v
        addfood();
        addsalt();
        stirfry();   //v
        end();      //v
    }

    //加热方法
    public void heating(){
        System.out.println("开火...");
    };

    //添加食物
    public abstract void addfood();

    //加盐
    public abstract void addsalt();

    //翻炒
    public  void stirfry(){
        System.out.println("翻炒中...");
    };

    //出锅
    public  void end(){
        System.out.println("出锅....");
    };


}


```

```java
/*
* 继承模板，实现方法
*/
public class AutoCookMachine extends CookTemplate{

    @Override
    public void addfood() {
        System.out.println("放了三个小白菜");
    }

    @Override
    public void addsalt() {
        System.out.println("放了三勺盐");
    }
}

```

```java
public static void main(String[] args) {

        AutoCookMachine cookMachine = new AutoCookMachine();
        //实际调用的是父类的方法，但是细节都是子类所实现的
        cookMachine.cook();

    }
```

## 使用场景

什么场景用到？
Spring的整个继承体系都基本用到模板方法;
BeanFactory.getBean(1,2,3,4)--A1---A2---A3---A4（全部被完成）
JdbcTemplate、RedisTemplate都允许我们再扩展.....
我们自己的系统也应该使用模板方法组织类结构
......



# 策略模式

策略（Strategy）模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。属于对象行为模式。

![image-20211020195018340](https://image.imxyu.cn/file/image-20211020195018340.png)

## 实例：游戏策略

```java
public interface GameStrategy {

    //战斗策略
    void warStrategy();
}

```

```java

/**
 * 稳健运营策略(具体策略)
 */
public class SteadyStrategy implements GameStrategy {
    @Override
    public void warStrategy() {
        System.out.println("各路小心...及时支援...");
    }
}


```

```java
/**
 * 冲锋向前策略(具体策略)
 */
public class UziStrategy implements GameStrategy{
    @Override
    public void warStrategy() {
        System.out.println("uzi.....");
    }
}
```

```java

/**
 * 环境类
 */
public class TeamGNR {

    //抽取游戏策略算法，并进行引用
    private GameStrategy gameStrategy;

    public void setGameStrategy(GameStrategy gameStrategy) {
        this.gameStrategy = gameStrategy;
    }

    public void startGame(){
        System.out.println("游戏开始.....");
        //游戏策略
        //
        gameStrategy.warStrategy();
        System.out.println("win......");
    }
}
```

```java

public class MainTest {

    public static void main(String[] args) {

        TeamGNR gnr = new TeamGNR();

        gnr.setGameStrategy(new RandomStrategy()); //设置相应的策略
        gnr.startGame();
    }
}
```

当我们要扩展一个策略时，只需要new一个类实现接口就可以

```java
//添加新的策略
public class RandomStrategy implements GameStrategy{
    @Override
    public void warStrategy() {
        System.out.println("大乱斗...");
    }
}

```

## 使用场景

什么场景用到？
使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句
什么是Spring的 InstantiationStrategy
线程池拒绝策略

......



# 状态模式

状态模式和策略模式非常像，不过状态模式在策略的基础上添加了状态，会有状态之间的流转

![image-20211020200910501](https://image.imxyu.cn/file/image-20211020200910501.png)

```java

/**
 * 抽象状态
 */
public interface TeamState {


    //玩游戏
    void playGame();

    //切换到下一个状态
    TeamState next();
}

```

```java
/**
 * 竞赛状态
 */
public class MatchState implements TeamState{
    @Override
    public void playGame() {
        System.out.println("全力以赴打比赛....");
    }


    //状态模式的核心
    @Override
    public TeamState next() {
        return new VocationState();
    }
}

```

```java
/**
 * 吃牛肉面状态
 */
public class BeafNodleState implements TeamState {

    @Override
    public void playGame() {
        System.out.println("饱饱的一顿牛肉面......中了诅咒，输了");
    }

    @Override
    public TeamState next() {
        return new MatchState();
    }
}

```

```java
/**
 * 休假状态
 */
public class VocationState implements TeamState {
    @Override
    public void playGame() {
        System.out.println("三亚旅游真舒服....饿了...不玩游戏");
        //状态流转

    }

    @Override
    public TeamState next() {  //下一个状态
        return new BeafNodleState();
    }
}
```

```java
/**
 * 环境类：
 */
public class SKTTeam {


    private TeamState teamState;  //状态

    public void setTeamState(TeamState teamState) {
        this.teamState = teamState;
    }

    //开始游戏
    public void startGame(){
        //状态不同会导致不同的游戏结果
        teamState.playGame();
    }


    //下一个状态
    void nextState(){
        teamState = teamState.next();
    }
}

```

```java
/**
 * 状态切换
 */
public class MainTest {

    public static void main(String[] args) {
        SKTTeam sktTeam = new SKTTeam();
        TeamState state = new VocationState();
        sktTeam.setTeamState(state);
        sktTeam.startGame();
//        sktTeam.startGame();
//
//        sktTeam.nextState();

//        sktTeam.startGame();
//
//        sktTeam.nextState();
//        sktTeam.startGame();

        state = state.next();
        sktTeam.setTeamState(state);
        sktTeam.startGame();
    }
}
```

## 使用场景

什么场景用到？
策略模式和状态模式是一样的？
状态模式核心需要具体状态类能在必要的时候切换状态
流程框架与状态机
......